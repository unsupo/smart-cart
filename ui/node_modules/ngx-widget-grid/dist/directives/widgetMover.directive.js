import { Directive, ElementRef, forwardRef, HostListener, Inject, Renderer2 } from '@angular/core';
import { NgxWidgetGridComponent } from '../components/grid/grid.component';
import { GridRectangle } from '../models/GridRectangle.model';
import { NgxWidgetComponent } from '../components/widget/widget.component';
import { PathIterator } from '../models/PathIterator.model';
var NgxWidgetMoverDirective = /** @class */ (function () {
    function NgxWidgetMoverDirective(el, renderer, gridCmp, widgetCmp) {
        this.el = el;
        this.renderer = renderer;
        this.gridCmp = gridCmp;
        this.widgetCmp = widgetCmp;
        this.enableDrag = null;
    }
    NgxWidgetMoverDirective.prototype.onDown = function (event) {
        event.preventDefault();
        this.renderer.addClass(this.widgetCmp.getEl().nativeElement, 'wg-moving');
        this.mouseDownPosition = { x: event.clientX, y: event.clientY };
        var widgetContainer = this.widgetCmp.getEl().nativeElement;
        this.startPosition = this.gridCmp.getWidgetPosition(this.widgetCmp);
        this.startRender = {
            top: widgetContainer.offsetTop,
            left: widgetContainer.offsetLeft,
            height: widgetContainer.clientHeight,
            width: widgetContainer.clientWidth
        }; // pixel values
        var eventOffsetX = event.offsetX || event.layerX;
        var eventOffsetY = event.offsetY || event.layerY;
        this.desiredPosition = { top: this.startRender.top, left: this.startRender.left };
        this.moverOffset = new GridRectangle({
            top: eventOffsetY + this.el.nativeElement.offsetTop || 0,
            left: eventOffsetX + this.el.nativeElement.offsetLeft || 0
        });
        this.gridPositions = this.gridCmp.getGridRectangle();
        this.cellHeight = (this.gridCmp.grid.cellSize.height / 100) * this.gridPositions.height;
        this.cellWidth = (this.gridCmp.grid.cellSize.width / 100) * this.gridPositions.width;
        this.enableDrag = this.widgetCmp.getConfig().getId();
    };
    NgxWidgetMoverDirective.prototype.onUp = function (event) {
        if (this.enableDrag === this.widgetCmp.getConfig().getId()) {
            event.preventDefault();
            var finalPos = this.determineFinalPos(this.startPosition, this.desiredPosition, this.startRender, this.cellHeight, this.cellWidth);
            this.gridCmp.resetHighlights();
            this.renderer.removeClass(this.widgetCmp.getEl().nativeElement, 'wg-moving');
            this.widgetCmp.position = finalPos;
            this.gridCmp.updateWidget(this.widgetCmp);
            this.enableDrag = null;
        }
    };
    NgxWidgetMoverDirective.prototype.onMove = function (event) {
        if (this.enableDrag === this.widgetCmp.getConfig().getId()) {
            event.preventDefault();
            var eventClientX = event.clientX, eventClientY = event.clientY;
            var startRender = this.startRender;
            var gridDimensions = this.gridPositions;
            var desiredPosition = this.desiredPosition;
            // normalize the drag position
            var dragPositionX = Math.round(eventClientX) - gridDimensions.left, dragPositionY = Math.round(eventClientY) - gridDimensions.top;
            desiredPosition.top = Math.min(Math.max(dragPositionY - this.moverOffset.top, 0), gridDimensions.height - startRender.height - 1);
            desiredPosition.left = Math.min(Math.max(dragPositionX - this.moverOffset.left, 0), gridDimensions.width - startRender.width - 1);
            var currentFinalPos = this.determineFinalPos(this.startPosition, this.desiredPosition, this.startRender, this.cellHeight, this.cellWidth);
            this.gridCmp.highlightArea(currentFinalPos);
            this.renderer.setStyle(this.widgetCmp.getEl().nativeElement, 'top', desiredPosition.top + 'px');
            this.renderer.setStyle(this.widgetCmp.getEl().nativeElement, 'left', desiredPosition.left + 'px');
        }
    };
    NgxWidgetMoverDirective.prototype.getAnchor = function (val, max) {
        return (val % max) > (max / 2) ? val + Math.floor(max) : val;
    };
    NgxWidgetMoverDirective.prototype.determineFinalPos = function (startPos, desiredPos, startRender, cellHt, cellWd) {
        if (startRender.top === desiredPos.top && startRender.left === desiredPos.left) {
            return startPos;
        }
        var anchorTop = this.getAnchor(desiredPos.top, cellHt), anchorLeft = this.getAnchor(desiredPos.left, cellWd);
        var movedDown = anchorTop >= startRender.top, movedRight = anchorLeft >= startRender.left;
        var desiredFinalPosition = this.gridCmp.rasterizeCoords(anchorLeft, anchorTop);
        var path = new PathIterator(desiredFinalPosition, startPos);
        while (path.hasNext()) {
            var currPos = path.next();
            var targetArea = new GridRectangle({
                top: currPos.top,
                left: currPos.left,
                height: startPos.height,
                width: startPos.width
            });
            var options = {
                excludedArea: startPos,
                fromBottom: movedDown,
                fromRight: movedRight
            };
            if (!this.gridCmp.isAreaObstructed(targetArea, options)) {
                // try to get closer to the desired position by leaving the original path
                var top_1 = targetArea.top, left = targetArea.left, height = targetArea.height, width = targetArea.width;
                if (desiredFinalPosition.top < top_1) {
                    var checkRect = new GridRectangle({ top: top_1 - 1, left: left, height: height, width: width }), isRectVacant = !this.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.top <= targetArea.top - 1 && isRectVacant) {
                        targetArea.top--;
                    }
                }
                else if (desiredFinalPosition.top > top_1) {
                    var checkRect = new GridRectangle({ top: top_1 + 1, left: left, height: height, width: width }), isRectVacant = !this.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.top >= targetArea.top + 1 && isRectVacant) {
                        targetArea.top++;
                    }
                }
                top_1 = targetArea.top;
                if (desiredFinalPosition.left < left) {
                    var checkRect = new GridRectangle({ top: top_1, left: left - 1, height: height, width: width }), isRectVacant = !this.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.left <= targetArea.left - 1 && isRectVacant) {
                        targetArea.left--;
                    }
                }
                else if (desiredFinalPosition.left > left) {
                    var checkRect = new GridRectangle({ top: top_1, left: left + 1, height: height, width: width }), isRectVacant = !this.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.left >= targetArea.left + 1 && isRectVacant) {
                        targetArea.left++;
                    }
                }
                return new GridRectangle(targetArea);
            }
        }
        return new GridRectangle(startPos);
    };
    NgxWidgetMoverDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngx-widget-mover]'
                },] },
    ];
    /** @nocollapse */
    NgxWidgetMoverDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
        { type: NgxWidgetGridComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return NgxWidgetGridComponent; }),] },] },
        { type: NgxWidgetComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return NgxWidgetComponent; }),] },] },
    ]; };
    NgxWidgetMoverDirective.propDecorators = {
        'onDown': [{ type: HostListener, args: ['mousedown', ['$event'],] },],
        'onUp': [{ type: HostListener, args: ['window:mouseup', ['$event'],] },],
        'onMove': [{ type: HostListener, args: ['window:mousemove', ['$event'],] },],
    };
    return NgxWidgetMoverDirective;
}());
export { NgxWidgetMoverDirective };
//# sourceMappingURL=widgetMover.directive.js.map