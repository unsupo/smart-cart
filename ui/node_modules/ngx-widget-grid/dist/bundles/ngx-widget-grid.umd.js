(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/platform-browser'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/platform-browser', '@angular/common'], factory) :
	(factory((global.ngx = global.ngx || {}, global.ngx.widgetgrid = global.ngx.widgetgrid || {}),global.ng.core,global.ng.platformBrowser,global.ng.common));
}(this, (function (exports,_angular_core,_angular_platformBrowser,_angular_common) { 'use strict';

var Utils = /** @class */ (function () {
    function Utils() {
    }
    Utils.isNumber = function (val) {
        return typeof val === 'number';
    };
    Utils.isDefined = function (val) {
        return val !== undefined;
    };
    Utils.isObject = function (val) {
        return typeof val === 'object';
    };
    return Utils;
}());
var RESIZE_DIRECTIONS = {
    topLeft: 'NW',
    top: 'N',
    topRight: 'NE',
    right: 'E',
    bottomRight: 'SE',
    bottom: 'S',
    bottomLeft: 'SW',
    left: 'W'
};
var ALL_DIRECTIONS = [
    RESIZE_DIRECTIONS.bottom,
    RESIZE_DIRECTIONS.left,
    RESIZE_DIRECTIONS.right,
    RESIZE_DIRECTIONS.top,
    RESIZE_DIRECTIONS.bottomLeft,
    RESIZE_DIRECTIONS.bottomRight,
    RESIZE_DIRECTIONS.topLeft,
    RESIZE_DIRECTIONS.topRight
];

var NgxGridOverlayComponent = /** @class */ (function () {
    function NgxGridOverlayComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.activeHighlight = null;
        this.gridRows = [];
        this.gridCols = [];
        this._showGrid = false;
    }
    Object.defineProperty(NgxGridOverlayComponent.prototype, "rows", {
        set: function (rows) {
            this.updateGridLines(this.renderer, this.showGrid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGridOverlayComponent.prototype, "cols", {
        set: function (rows) {
            this.updateGridLines(this.renderer, this.showGrid);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGridOverlayComponent.prototype, "renderer", {
        get: function () {
            return this._renderer;
        },
        set: function (renderer) {
            this._renderer = renderer;
            if (Utils.isDefined(renderer)) {
                this.updateGridLines(renderer, this.showGrid);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGridOverlayComponent.prototype, "highlight", {
        get: function () {
            return this._highlight;
        },
        set: function (highlight) {
            this._highlight = highlight;
            this.clearHighlight();
            if (highlight) {
                this.highlightArea(highlight, this.renderer);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxGridOverlayComponent.prototype, "showGrid", {
        get: function () {
            return this._showGrid;
        },
        set: function (showGrid) {
            this._showGrid = showGrid;
            this.updateGridLines(this.renderer, showGrid);
        },
        enumerable: true,
        configurable: true
    });
    NgxGridOverlayComponent.prototype.updateGridLines = function (renderer, showGrid) {
        this.clearGridLines();
        if (showGrid) {
            this.showGridLines(renderer);
        }
    };
    NgxGridOverlayComponent.prototype.clearHighlight = function () {
        this.activeHighlight = null;
    };
    NgxGridOverlayComponent.prototype.clearGridLines = function () {
        this.gridRows.splice(0);
        this.gridCols.splice(0);
    };
    NgxGridOverlayComponent.prototype.highlightArea = function (area, renderer) {
        var cellSize = renderer.grid.cellSize, cellHeight = cellSize.height, cellWidth = cellSize.width;
        this.activeHighlight = {
            x: (area.left - 1) * cellWidth + '%',
            y: (area.top - 1) * cellHeight + '%',
            height: area.height * cellHeight + '%',
            width: area.width * cellWidth + '%'
        };
        this.sanitizer.bypassSecurityTrustStyle(this.activeHighlight);
    };
    NgxGridOverlayComponent.prototype.showGridLines = function (renderer) {
        var this$1 = this;

        var cellHeight = renderer.grid.cellSize.height, cellWidth = renderer.grid.cellSize.width, height = cellHeight + '%', width = cellWidth + '%', rows = renderer.grid.rows, cols = renderer.grid.columns;
        for (var i = 1; i < rows; i += 2) {
            var y = void 0, h = void 0, row = void 0;
            y = (i * cellHeight) + '%';
            h = 'calc(' + height + ' - 1px)';
            row = {
                y: this$1.sanitizer.bypassSecurityTrustStyle(y),
                height: this$1.sanitizer.bypassSecurityTrustStyle(h)
            };
            this$1.gridRows.push(row);
        }
        for (var i = 1; i < cols; i += 2) {
            var x = void 0, w = void 0, col = void 0;
            x = (i * cellWidth) + '%';
            w = 'calc(' + width + ' - 1px)';
            col = {
                x: this$1.sanitizer.bypassSecurityTrustStyle(x),
                width: this$1.sanitizer.bypassSecurityTrustStyle(w)
            };
            this$1.gridCols.push(col);
        }
    };
    NgxGridOverlayComponent.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: 'ngx-grid-overlay',
                    styles: ["\n                 .wg-grid-overlay{overflow:hidden}.wg-grid-overlay *{position:absolute;height:100%;width:100%}.wg-grid-overlay .wg-preview-item{position:absolute;display:inline-block}.wg-grid-overlay .wg-preview-item.wg-preview-row{width:100%;border-top:1px dotted #d7d7d7;border-bottom:1px solid #f0f0f0}.wg-grid-overlay .wg-preview-item.wg-preview-column{height:100%;border-left:1px dotted #d7d7d7;border-right:1px solid #f0f0f0}.wg-grid-overlay .wg-preview-item.wg-preview-highlight{background-color:rgba(0,113,188,0.2);z-index:1}\n               "],
                    template: "\n                 <div class=\"wg-grid-overlay\">\n                     <div *ngFor=\"let row of gridRows\" class=\"wg-preview-item wg-preview-row\" [style.height]=\"row.height\"\n                          [style.top]=\"row.y\"></div>\n                     <div *ngFor=\"let column of gridCols\" class=\"wg-preview-item wg-preview-column\" [style.width]=\"column.width\"\n                          [style.left]=\"column.x\"></div>\n                     <div *ngIf=\"activeHighlight\" class=\"wg-preview-item wg-preview-highlight\" [style.top]=\"activeHighlight.y\"\n                          [style.height]=\"activeHighlight.height\"\n                          [style.left]=\"activeHighlight.x\" [style.width]=\"activeHighlight.width\"></div>\n                 </div>\n               "
                } ] } ];
    /** @nocollapse */
    NgxGridOverlayComponent.ctorParameters = function () { return [
        { type: _angular_platformBrowser.DomSanitizer, } ]; };
    NgxGridOverlayComponent.propDecorators = {
        'rows': [{ type: _angular_core.Input } ],
        'cols': [{ type: _angular_core.Input } ],
        'renderer': [{ type: _angular_core.Input } ],
        'highlight': [{ type: _angular_core.Input } ],
        'showGrid': [{ type: _angular_core.Input } ],
    };
    return NgxGridOverlayComponent;
}());

var GridRectangle = /** @class */ (function () {
    function GridRectangle(obj) {
        this.top = 0;
        this.left = 0;
        this.width = 0;
        this.height = 0;
        if (obj) {
            this.top = obj.top;
            this.left = obj.left;
            this.width = obj.width;
            this.height = obj.height;
        }
    }
    GridRectangle.create = function (start, end) {
        var width = end.left - start.left + 1, height = end.top - start.top + 1;
        return new GridRectangle({ top: start.top, left: start.left, width: width, height: height });
    };
    GridRectangle.prototype.getBottom = function () {
        return this.top + this.height - 1;
    };
    GridRectangle.prototype.getRight = function () {
        return this.left + this.width - 1;
    };
    GridRectangle.prototype.getSurfaceArea = function () {
        return this.height * this.width;
    };
    return GridRectangle;
}());

var WidgetConfig = /** @class */ (function () {
    function WidgetConfig(gridArea) {
        this.top = 0;
        this.left = 0;
        this.width = 0;
        this.height = 0;
        this.id = this.generateUID();
        if (gridArea) {
            this.top = gridArea.top || 0;
            this.left = gridArea.left || 0;
            this.width = gridArea.width || 0;
            this.height = gridArea.height || 0;
        }
    }
    WidgetConfig.prototype.generateUID = function () {
        return 'vmDashboardWidget-' + ++WidgetConfig.widgetCount;
    };
    Object.defineProperty(WidgetConfig.prototype, "position", {
        get: function () {
            return new GridRectangle({ top: this.top, left: this.left, width: this.width, height: this.height });
        },
        set: function (gridArea) {
            this.top = Utils.isNumber(gridArea.top) ? gridArea.top : this.top;
            this.left = Utils.isNumber(gridArea.left) ? gridArea.left : this.left;
            this.width = Utils.isNumber(gridArea.width) ? gridArea.width : this.width;
            this.height = Utils.isNumber(gridArea.height) ? gridArea.height : this.height;
        },
        enumerable: true,
        configurable: true
    });
    WidgetConfig.prototype.getId = function () {
        return this.id;
    };
    WidgetConfig.widgetCount = 0;
    return WidgetConfig;
}());

var NgxWidgetComponent = /** @class */ (function () {
    function NgxWidgetComponent(elRef) {
        this.elRef = elRef;
        this.positionChange = new _angular_core.EventEmitter();
        this.movable = false;
        this._resizable = false;
        this.allDirections = RESIZE_DIRECTIONS;
        this._resizeDirections = ALL_DIRECTIONS;
        this.isTopResizable = false;
        this.isRightResizable = false;
        this.isBottomResizable = false;
        this.isLeftResizable = false;
        this.isTopRightResizable = false;
        this.isTopLeftResizable = false;
        this.isBottomRightResizable = false;
        this.isBottomLeftResizable = false;
        this.widgetConfig = new WidgetConfig(this.position);
    }
    Object.defineProperty(NgxWidgetComponent.prototype, "position", {
        get: function () {
            return this._position;
        },
        set: function (position) {
            this._position = position;
            this.widgetConfig.position = position;
            this.positionChange.emit(position);
        },
        enumerable: true,
        configurable: true
    });
    
    Object.defineProperty(NgxWidgetComponent.prototype, "resizable", {
        get: function () {
            return this._resizable;
        },
        set: function (resizable) {
            this._resizable = resizable;
            if (resizable) {
                this.setResizeDirections();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxWidgetComponent.prototype, "resizeDirections", {
        get: function () {
            return this._resizeDirections;
        },
        set: function (dirs) {
            this._resizeDirections = dirs.filter(function (dir) {
                return ALL_DIRECTIONS.indexOf(dir.toUpperCase()) !== -1;
            });
            this.setResizeDirections();
        },
        enumerable: true,
        configurable: true
    });
    NgxWidgetComponent.prototype.setResizeDirections = function () {
        var _this = this;
        this.isTopResizable = false;
        this.isRightResizable = false;
        this.isBottomResizable = false;
        this.isLeftResizable = false;
        this.isTopRightResizable = false;
        this.isTopLeftResizable = false;
        this.isBottomRightResizable = false;
        this.isBottomLeftResizable = false;
        this._resizeDirections.forEach(function (dir) {
            switch (dir) {
                case RESIZE_DIRECTIONS.top:
                    _this.isTopResizable = true;
                    break;
                case RESIZE_DIRECTIONS.left:
                    _this.isLeftResizable = true;
                    break;
                case RESIZE_DIRECTIONS.bottom:
                    _this.isBottomResizable = true;
                    break;
                case RESIZE_DIRECTIONS.right:
                    _this.isRightResizable = true;
                    break;
                case RESIZE_DIRECTIONS.topLeft:
                    _this.isTopLeftResizable = true;
                    break;
                case RESIZE_DIRECTIONS.topRight:
                    _this.isTopRightResizable = true;
                    break;
                case RESIZE_DIRECTIONS.bottomLeft:
                    _this.isBottomLeftResizable = true;
                    break;
                case RESIZE_DIRECTIONS.bottomRight:
                    _this.isBottomRightResizable = true;
                    break;
                default:
            }
        });
    };
    NgxWidgetComponent.prototype.getConfig = function () {
        return this.widgetConfig;
    };
    NgxWidgetComponent.prototype.getEl = function () {
        return this.elRef;
    };
    NgxWidgetComponent.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: 'ngx-widget',
                    styles: ["\n                 :host{position:absolute}:host .wg-widget-content{position:absolute;overflow:hidden;height:100%;width:100%}:host.wg-moving .wg-widget-content,:host.wg-resizing .wg-widget-content{opacity:0.2;z-index:18}:host.wg-moving .wg-widget-edit-move{cursor:move;cursor:-webkit-grabbing}.wg-widget-edit-move{position:absolute;top:6px;right:6px;bottom:6px;left:6px;z-index:20;-ms-touch-action:none;touch-action:none;cursor:move;cursor:-webkit-grab}.wg-widget-edit-resize{position:absolute;-ms-touch-action:none;touch-action:none;top:0;right:0;bottom:0;left:0;z-index:15}.wg-resize{position:absolute}.wg-resize-diag{border-color:rgba(0,113,188,0.75);border-style:solid;width:0;height:0;z-index:1}.wg-resize-diag:hover{border-color:rgba(0,138,229,0.75)}.wg-resize-diag.dragging{border-color:rgba(0,174,239,0.75)}.wg-resize-axis{background-color:rgba(0,113,188,0.12)}.wg-resize-axis.dragging{background-color:rgba(0,174,239,0.24)}.wg-resize-nw{top:0;left:0;cursor:nw-resize;border-width:16px 16px 0 0;border-right-color:transparent !important}.wg-resize-ne{top:0;right:0;cursor:ne-resize;border-width:16px 0 0 16px;border-left-color:transparent !important}.wg-resize-se{bottom:0;right:0;cursor:se-resize;border-width:0 0 16px 16px;border-left-color:transparent !important}.wg-resize-sw{bottom:0;left:0;cursor:sw-resize;border-width:0 16px 16px 0;border-right-color:transparent !important}.wg-resize-n{top:0;right:0;left:0;height:6px;cursor:n-resize}.wg-resize-e{top:0;right:0;bottom:0;width:6px;cursor:e-resize}.wg-resize-s{right:0;bottom:0;left:0;height:6px;cursor:s-resize}.wg-resize-w{top:0;bottom:0;left:0;width:6px;cursor:w-resize}[hidden]{display:none}\n               "],
                    template: "\n                 <div class=\"wg-widget-content\">\n                     <ng-content></ng-content>\n                 </div>\n                 <div ngx-widget-mover *ngIf=\"movable\" class=\"wg-widget-edit-move\"></div>\n                 <div *ngIf=\"resizable\" class=\"wg-widget-edit-resize\">\n\n                     <div class=\"wg-resize wg-resize-axis wg-resize-n\" [ngx-widget-resizer]=\"allDirections.top\"\n                          [hidden]=\"!isTopResizable\"></div>\n                     <div class=\"wg-resize wg-resize-axis wg-resize-e\" [ngx-widget-resizer]=\"allDirections.right\"\n                          [hidden]=\"!isRightResizable\"></div>\n                     <div class=\"wg-resize wg-resize-axis wg-resize-s\" [ngx-widget-resizer]=\"allDirections.bottom\"\n                          [hidden]=\"!isBottomResizable\"></div>\n                     <div class=\"wg-resize wg-resize-axis wg-resize-w\" [ngx-widget-resizer]=\"allDirections.left\"\n                          [hidden]=\"!isLeftResizable\"></div>\n                     <div class=\"wg-resize wg-resize-diag wg-resize-nw\" [ngx-widget-resizer]=\"allDirections.topLeft\"\n                          [hidden]=\"!isTopLeftResizable\"></div>\n                     <div class=\"wg-resize wg-resize-diag wg-resize-ne\" [ngx-widget-resizer]=\"allDirections.topRight\"\n                          [hidden]=\"!isTopRightResizable\"></div>\n                     <div class=\"wg-resize wg-resize-diag wg-resize-se\" [ngx-widget-resizer]=\"allDirections.bottomRight\"\n                          [hidden]=\"!isBottomRightResizable\"></div>\n                     <div class=\"wg-resize wg-resize-diag wg-resize-sw\" [ngx-widget-resizer]=\"allDirections.bottomLeft\"\n                          [hidden]=\"!isBottomLeftResizable\"></div>\n                 </div>\n               "
                } ] } ];
    /** @nocollapse */
    NgxWidgetComponent.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, } ]; };
    NgxWidgetComponent.propDecorators = {
        'position': [{ type: _angular_core.Input } ],
        'positionChange': [{ type: _angular_core.Output } ],
        'movable': [{ type: _angular_core.Input } ],
        'resizable': [{ type: _angular_core.Input } ],
        'resizeDirections': [{ type: _angular_core.Input } ],
    };
    return NgxWidgetComponent;
}());

var CellSize = /** @class */ (function () {
    function CellSize(rowCount, columnCount) {
        this._height = 0;
        this._width = 0;
        var height = rowCount ? 100 / rowCount : 0, width = columnCount ? 100 / columnCount : 0;
        this._height = height;
        this._width = width;
    }
    
    Object.defineProperty(CellSize.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellSize.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    return CellSize;
}());

var Grid = /** @class */ (function () {
    function Grid(rows, columns) {
        this._widgets = [];
        this._rows = 3;
        this._columns = 3;
        if (rows) {
            this._rows = rows;
        }
        if (columns) {
            this._columns = columns;
        }
        this._cellSize = new CellSize(this._rows, this._columns);
    }
    Object.defineProperty(Grid.prototype, "rows", {
        get: function () {
            return this._rows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "columns", {
        get: function () {
            return this._columns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "cellSize", {
        get: function () {
            return this._cellSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "widgets", {
        get: function () {
            return this._widgets;
        },
        enumerable: true,
        configurable: true
    });
    Grid.prototype.add = function (widget) {
        this._widgets.push(widget);
    };
    Grid.prototype.remove = function (widget) {
        var widgetIndex = this._widgets.indexOf(widget);
        if (widgetIndex > -1) {
            this._widgets.splice(widgetIndex, 1);
        }
    };
    Grid.prototype.removeAll = function () {
        this._widgets.splice(0);
    };
    Grid.prototype.hasWidget = function (widget) {
        var widgetIndex = this._widgets.indexOf(widget);
        return widgetIndex > -1;
    };
    Grid.prototype.resize = function (rows, columns) {
        columns = columns || 0;
        rows = rows || 0;
        if (columns > 0 && rows > 0 && columns !== this._columns || rows !== this._rows) {
            this._columns = columns;
            this._rows = rows;
            this._cellSize = new CellSize(this._rows, this._columns);
        }
    };
    return Grid;
}());

var GridPoint = /** @class */ (function () {
    function GridPoint(top, left) {
        this._top = top;
        this._left = left;
    }
    Object.defineProperty(GridPoint.prototype, "top", {
        get: function () {
            return this._top;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GridPoint.prototype, "left", {
        get: function () {
            return this._left;
        },
        enumerable: true,
        configurable: true
    });
    return GridPoint;
}());

var GridRenderer = /** @class */ (function () {
    function GridRenderer(grid) {
        this.positions = {};
        this.obstructions = [];
        this.grid = grid || new Grid();
    }
    Object.defineProperty(GridRenderer.prototype, "grid", {
        get: function () {
            return this._grid;
        },
        set: function (grid) {
            var this$1 = this;

            this._grid = grid;
            this.positions = {};
            this.cachedNextPosition = undefined;
            this.obstructions = [];
            for (var i = 0; i < grid.rows * grid.columns; i++) {
                this$1.obstructions[i] = 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    GridRenderer.prototype.rasterizeCoords = function (left, top, gridWidth, gridHeight) {
        left = Math.min(Math.max(left, 0), gridWidth - 1);
        top = Math.min(Math.max(top, 0), gridHeight - 1);
        var x = Math.floor(top / gridHeight * this.grid.rows) + 1, y = Math.floor(left / gridWidth * this.grid.columns) + 1;
        return new GridPoint(x, y);
    };
    GridRenderer.prototype.getWidgetIdAt = function (i, j) {
        var this$1 = this;

        for (var widgetId in this$1.positions) {
            if (this$1.positions.hasOwnProperty(widgetId)) {
                var position = this$1.positions[widgetId];
                if (position.top <= i && i <= (position.top + position.height - 1) &&
                    position.left <= j && j <= (position.left + position.width - 1)) {
                    return widgetId;
                }
            }
        }
        return null;
    };
    GridRenderer.prototype.getWidgetPosition = function (widget) {
        return this.positions[widget.getId()];
    };
    GridRenderer.prototype.setWidgetPosition = function (widgetId, newPosition) {
        var currPosition = this.positions[widgetId];
        if (currPosition) {
            this.setObstructionValues(currPosition, 0);
        }
        newPosition = new GridRectangle({
            top: Utils.isNumber(newPosition.top) ? newPosition.top : currPosition.top,
            left: Utils.isNumber(newPosition.left) ? newPosition.left : currPosition.left,
            width: Utils.isNumber(newPosition.width) ? newPosition.width : currPosition.width,
            height: Utils.isNumber(newPosition.height) ? newPosition.height : currPosition.height,
        });
        this.positions[widgetId] = newPosition;
        this.setObstructionValues(this.positions[widgetId], 1);
        this.cachedNextPosition = undefined;
    };
    GridRenderer.prototype.hasSpaceLeft = function () {
        for (var _i = 0, _a = this.obstructions; _i < _a.length; _i++) {
            var obstruction = _a[_i];
            if (!obstruction) {
                return true;
            }
        }
        return false;
    };
    GridRenderer.prototype.getNextPosition = function () {
        if (this.cachedNextPosition !== undefined) {
            return this.cachedNextPosition;
        }
        if (!this.hasSpaceLeft()) {
            return null;
        }
        var maxPosition = this.findLargestEmptyArea();
        this.cachedNextPosition = maxPosition;
        return maxPosition;
    };
    GridRenderer.prototype.isObstructed = function (i, j, excludedArea) {
        // obstructed if (i, j) exceeds the grid's regular non-expanding boundaries
        if (i < 1 || j < 1 || j > this.grid.columns || i > this.grid.rows) {
            return true;
        }
        var bottom = excludedArea && excludedArea.top + excludedArea.height - 1;
        var right = excludedArea && excludedArea.left + excludedArea.width - 1;
        // pass if (i, j) is within the excluded area, if any
        if (excludedArea &&
            excludedArea.top <= i &&
            i <= bottom &&
            excludedArea.left <= j &&
            j <= right) {
            return false;
        }
        return this._isObstructed(i, j);
    };
    GridRenderer.prototype._isObstructed = function (i, j) {
        return this.obstructions[(i - 1) * this.grid.columns + (j - 1)] === 1;
    };
    GridRenderer.prototype.isAreaObstructed = function (area, options) {
        var this$1 = this;

        if (!area) {
            return false;
        }
        options = Utils.isObject(options) ? options : {};
        var top = area.top, left = area.left, bottom = area.bottom || area.top + area.height - 1, right = area.right || area.left + area.width - 1;
        if (!Utils.isNumber(top) || !Utils.isNumber(left) || !Utils.isNumber(bottom) || !Utils.isNumber(right)) {
            return false;
        }
        var verticalStart = options.fromBottom ? bottom : top, verticalStep = options.fromBottom ? -1 : 1, verticalEnd = (options.fromBottom ? top : bottom) + verticalStep;
        var horizontalStart = options.fromRight ? right : left, horizontalStep = options.fromRight ? -1 : 1, horizontalEnd = (options.fromRight ? left : right) + horizontalStep;
        for (var i = verticalStart; i !== verticalEnd; i += verticalStep) {
            for (var j = horizontalStart; j !== horizontalEnd; j += horizontalStep) {
                if (this$1.isObstructed(i, j, options.excludedArea)) {
                    return true;
                }
            }
        }
        return false;
    };
    GridRenderer.prototype.getStyle = function (widgetId) {
        var render = this.positions[widgetId];
        if (!render) {
            return { display: 'none' };
        }
        return {
            top: ((render.top - 1) * this.grid.cellSize.height).toString() + '%',
            height: (render.height * this.grid.cellSize.height).toString() + '%',
            left: ((render.left - 1) * this.grid.cellSize.width).toString() + '%',
            width: (render.width * this.grid.cellSize.width).toString() + '%'
        };
    };
    GridRenderer.prototype.setObstructionValues = function (area, value) {
        var this$1 = this;

        for (var i = area.top - 1; i < area.top + area.height - 1; i++) {
            for (var j = area.left - 1; j < area.left + area.width - 1; j++) {
                this$1.obstructions[i * this$1.grid.columns + j] = value;
            }
        }
    };
    GridRenderer.prototype.findLargestEmptyArea = function () {
        var this$1 = this;

        var maxArea = null, currMaxArea = null, maxSurfaceArea = 0, currMaxSurfaceArea = 0;
        for (var i = 1; i <= this.grid.rows; i++) {
            for (var j = 1; j <= this.grid.columns; j++) {
                if (this$1._isObstructed(i, j)) {
                    continue;
                }
                var currAreaLimit = (this$1.grid.rows - i + 1) * (this$1.grid.columns - j + 1);
                if (currAreaLimit < maxSurfaceArea) {
                    break;
                }
                currMaxArea = this$1._findLargestEmptyAreaFrom(new GridPoint(i, j));
                currMaxSurfaceArea = currMaxArea.getSurfaceArea();
                if (currMaxSurfaceArea > maxSurfaceArea) {
                    maxSurfaceArea = currMaxSurfaceArea;
                    maxArea = currMaxArea;
                }
            }
        }
        return maxArea;
    };
    GridRenderer.prototype._findLargestEmptyAreaFrom = function (start) {
        var this$1 = this;

        if (!Utils.isDefined(this.grid) || !Utils.isNumber(this.grid.columns) || !Utils.isNumber(this.grid.rows)) {
            return null;
        }
        var maxArea = null, maxSurfaceArea = 0, endColumn = this.grid.columns;
        for (var i = start.top; i <= this.grid.rows; i++) {
            for (var j = start.left; j <= endColumn; j++) {
                if (this$1._isObstructed(i, j)) {
                    endColumn = j - 1;
                    continue;
                }
                var currHeight = (i - start.top + 1), currWidth = (j - start.left + 1), currSurfaceArea = currHeight * currWidth;
                if (currSurfaceArea > maxSurfaceArea) {
                    maxSurfaceArea = currSurfaceArea;
                    maxArea = new GridRectangle({
                        top: start.top,
                        left: start.left,
                        width: currWidth,
                        height: currHeight
                    });
                }
            }
        }
        return maxArea;
    };
    GridRenderer.prototype.render = function (grid, emitWidgetPositionUpdated) {
        var _this = this;
        this.grid = grid;
        var widgets = this.grid && this.grid.widgets ? this.grid.widgets : [];
        var unpositionedWidgets = [];
        widgets.forEach(function (widget) {
            var position = widget.position;
            if (position.width * position.height === 0 ||
                _this.isAreaObstructed(position)) {
                unpositionedWidgets.push(widget);
            }
            else {
                _this.setWidgetPosition(widget.getId(), position);
            }
        });
        unpositionedWidgets.forEach(function (widget) {
            var nextPosition = _this.getNextPosition();
            if (nextPosition !== null) {
                widget.position = nextPosition;
                _this.setWidgetPosition(widget.getId(), nextPosition);
            }
            else {
                widget.position = new GridRectangle();
                _this.setWidgetPosition(widget.getId(), new GridRectangle());
            }
            if (emitWidgetPositionUpdated) {
                emitWidgetPositionUpdated(widget);
            }
        });
    };
    return GridRenderer;
}());

var NgxWidgetGridComponent = /** @class */ (function () {
    function NgxWidgetGridComponent(el, _renderer) {
        this.el = el;
        this._renderer = _renderer;
        this.showGrid = false;
        this._highlightNextPosition = false;
        this.clickThrough = false;
        this.widgetPositionChangeEmitter = new _angular_core.EventEmitter();
        this.gridFullEmitter = new _angular_core.EventEmitter();
        this.gridAlreadyFull = false;
        this.grid = new Grid(this.rows, this.columns);
        this.gridRenderer = new GridRenderer(this.grid);
    }
    Object.defineProperty(NgxWidgetGridComponent.prototype, "rows", {
        get: function () {
            return this._rows;
        },
        set: function (rows) {
            this._rows = rows;
            this.updateGridSize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxWidgetGridComponent.prototype, "columns", {
        get: function () {
            return this._columns;
        },
        set: function (cols) {
            this._columns = cols;
            this.updateGridSize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxWidgetGridComponent.prototype, "highlightNextPosition", {
        get: function () {
            return this._highlightNextPosition;
        },
        set: function (highlightNext) {
            this._highlightNextPosition = highlightNext;
            if (highlightNext) {
                this.updateNextPositionHighlight();
            }
            else {
                this.resetHighlights();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgxWidgetGridComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.refreshWidgets();
        this.widgetComponents.changes.subscribe(function () {
            _this.clearGrid();
            _this.refreshWidgets();
        });
    };
    NgxWidgetGridComponent.prototype.refreshWidgets = function () {
        var _this = this;
        this.widgetComponents.forEach(function (widget) {
            if (!_this.hasWidget(widget)) {
                _this.addWidget(widget, true);
            }
            else {
            }
        });
        this.updateRendering();
    };
    NgxWidgetGridComponent.prototype.hasWidget = function (widget) {
        return this.grid.hasWidget(widget.getConfig());
    };
    NgxWidgetGridComponent.prototype.addWidget = function (widget, deferredRender) {
        this.grid.add(widget.getConfig());
        if (!deferredRender) {
            this.updateRendering();
        }
    };
    NgxWidgetGridComponent.prototype.clearGrid = function () {
        this.grid.removeAll();
    };
    NgxWidgetGridComponent.prototype.updateGridSize = function () {
        var columns = this.columns;
        var rows = this.rows;
        if (this.grid.columns !== columns || this.grid.rows !== rows) {
            this.grid.resize(rows, columns);
            this.updateRendering();
        }
    };
    NgxWidgetGridComponent.prototype.updateRendering = function () {
        var _this = this;
        this.gridRenderer.render(this.grid, this.emitUpdatePosition.bind(this));
        this.updateNextPositionHighlight();
        // TODO: retrieve all widgets and call their updateRendering
        if (this.widgetComponents) {
            this.widgetComponents.forEach(function (widget) {
                _this.updateWidget(widget);
            });
        }
    };
    NgxWidgetGridComponent.prototype.getGridRectangle = function () {
        var gridContainer = this.el.nativeElement;
        // c.f. jQuery#offset: https://github.com/jquery/jquery/blob/2d715940b9b6fdeed005cd006c8bf63951cf7fb2/src/offset.js#L93-105
        var rect = gridContainer.getBoundingClientRect();
        if (rect.width || rect.height || gridContainer.getClientRects().length) {
            var doc = gridContainer.ownerDocument;
            var docElem = doc.documentElement;
            return new GridRectangle({
                top: rect.top + window.pageYOffset - docElem.clientTop,
                left: rect.left + window.pageXOffset - docElem.clientLeft,
                height: rect.height,
                width: rect.width
            });
        }
        return new GridRectangle({ top: 0, left: 0, height: 0, width: 0 });
    };
    NgxWidgetGridComponent.prototype.rasterizeCoords = function (x, y) {
        return this.gridRenderer.rasterizeCoords(x, y, this.el.nativeElement.clientWidth, this.el.nativeElement.clientHeight);
    };
    NgxWidgetGridComponent.prototype.updateWidget = function (widget) {
        var this$1 = this;

        var config = widget.getConfig();
        var newPosition = config.position;
        var el = widget.getEl();
        this.gridRenderer.setWidgetPosition(config.getId(), newPosition);
        var widgetStyles = this.getWidgetStyle(widget);
        for (var style in widgetStyles) {
            if (widgetStyles.hasOwnProperty(style)) {
                this$1._renderer.setStyle(el.nativeElement, style, widgetStyles[style]);
            }
        }
        this.emitUpdatePosition(config);
        this.assessAvailableGridSpace();
    };
    NgxWidgetGridComponent.prototype.getWidgetPosition = function (widget) {
        return this.gridRenderer.getWidgetPosition(widget.getConfig());
    };
    NgxWidgetGridComponent.prototype.getWidgetStyle = function (widget) {
        return this.gridRenderer.getStyle(widget.getConfig().getId());
    };
    NgxWidgetGridComponent.prototype.isPointObstructed = function (i, j) {
        return this.gridRenderer ? this.gridRenderer.isObstructed(i, j) : true;
    };
    NgxWidgetGridComponent.prototype.isAreaObstructed = function (area, options) {
        return this.gridRenderer ? this.gridRenderer.isAreaObstructed(area, options) : true;
    };
    NgxWidgetGridComponent.prototype.highlightArea = function (area) {
        var _this = this;
        if (area.top && area.left && area.height && area.width) {
            setTimeout(function () {
                _this.highlightedArea = area;
            });
        }
    };
    NgxWidgetGridComponent.prototype.updateNextPositionHighlight = function () {
        if (this.highlightNextPosition) {
            this.highlightedArea = this.gridRenderer.getNextPosition();
        }
    };
    NgxWidgetGridComponent.prototype.getNextPosition = function () {
        return this.gridRenderer.getNextPosition();
    };
    NgxWidgetGridComponent.prototype.getPositions = function () {
        return this.grid.widgets;
    };
    NgxWidgetGridComponent.prototype.resetHighlights = function () {
        var _this = this;
        setTimeout(function () {
            _this.highlightedArea = null;
        });
    };
    NgxWidgetGridComponent.prototype.emitUpdatePosition = function (widget) {
        this.widgetPositionChangeEmitter.emit({
            index: this.getWidgetIndex(widget),
            newPosition: widget.position
        });
    };
    NgxWidgetGridComponent.prototype.getWidgetIndex = function (widgetConfig) {
        var this$1 = this;

        for (var i = this.grid.widgets.length - 1; i >= 0; i--) {
            if (this$1.grid.widgets[i].getId() === widgetConfig.getId()) {
                return i;
            }
        }
        return -1;
    };
    NgxWidgetGridComponent.prototype.assessAvailableGridSpace = function () {
        var gridHasSpaceLeft = this.gridRenderer.hasSpaceLeft();
        if (this.gridAlreadyFull) {
            if (gridHasSpaceLeft) {
                this.gridFullEmitter.emit(false);
                this.gridAlreadyFull = false;
            }
            else {
                /*No change to grid status. was and still is full*/
            }
        }
        else {
            if (!gridHasSpaceLeft) {
                this.gridFullEmitter.emit(true);
                this.gridAlreadyFull = true;
            }
            else {
                /*No change to grid status. had and still has available space*/
            }
        }
    };
    NgxWidgetGridComponent.decorators = [
        { type: _angular_core.Component, args: [{
                    selector: 'ngx-widget-grid',
                    styles: ["\n                 :host{height:100%;width:100%;position:absolute;overflow:hidden}\n               "],
                    template: "\n                 <ngx-grid-overlay [showGrid]=\"showGrid\"\n                                   [renderer]=\"gridRenderer\"\n                                   [highlight]=\"highlightedArea\"\n                                   [cols]=\"columns\"\n                                   [rows]=\"rows\">\n                 </ngx-grid-overlay>\n                 <div class=\"wg-grid-widgets\">\n                     <ng-content></ng-content>\n                 </div>\n               "
                } ] } ];
    /** @nocollapse */
    NgxWidgetGridComponent.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer2, } ]; };
    NgxWidgetGridComponent.propDecorators = {
        'rows': [{ type: _angular_core.Input } ],
        'columns': [{ type: _angular_core.Input } ],
        'showGrid': [{ type: _angular_core.Input } ],
        'highlightNextPosition': [{ type: _angular_core.Input } ],
        'clickThrough': [{ type: _angular_core.Input } ],
        'widgetPositionChangeEmitter': [{ type: _angular_core.Output, args: ['widgetPositionChange' ] } ],
        'gridFullEmitter': [{ type: _angular_core.Output, args: ['gridFull' ] } ],
        'widgetComponents': [{ type: _angular_core.ContentChildren, args: [NgxWidgetComponent ] } ],
    };
    return NgxWidgetGridComponent;
}());

var PathIterator = /** @class */ (function () {
    function PathIterator(start, end) {
        this.start = start;
        this.topDelta = end.top - start.top;
        this.leftDelta = end.left - start.left;
        this.steps = Math.max(Math.abs(this.topDelta), Math.abs(this.leftDelta));
        this.currStep = 0;
        this.currPos = null;
        this.nextPos = new GridPoint(start.top, start.left);
    }
    PathIterator.prototype.next = function () {
        this.currPos = this.nextPos;
        if (this.currStep < this.steps) {
            this.currStep++;
            var currTopDelta = Math.round((this.currStep / this.steps) * this.topDelta), currLeftDelta = Math.round((this.currStep / this.steps) * this.leftDelta);
            this.nextPos = new GridPoint(this.start.top + currTopDelta, this.start.left + currLeftDelta);
        }
        else {
            this.nextPos = null;
        }
        return this.currPos;
    };
    PathIterator.prototype.hasNext = function () {
        return this.nextPos !== null;
    };
    return PathIterator;
}());

var NgxWidgetMoverDirective = /** @class */ (function () {
    function NgxWidgetMoverDirective(el, renderer, gridCmp, widgetCmp) {
        this.el = el;
        this.renderer = renderer;
        this.gridCmp = gridCmp;
        this.widgetCmp = widgetCmp;
        this.enableDrag = null;
    }
    NgxWidgetMoverDirective.prototype.onDown = function (event) {
        event.preventDefault();
        this.renderer.addClass(this.widgetCmp.getEl().nativeElement, 'wg-moving');
        this.mouseDownPosition = { x: event.clientX, y: event.clientY };
        var widgetContainer = this.widgetCmp.getEl().nativeElement;
        this.startPosition = this.gridCmp.getWidgetPosition(this.widgetCmp);
        this.startRender = {
            top: widgetContainer.offsetTop,
            left: widgetContainer.offsetLeft,
            height: widgetContainer.clientHeight,
            width: widgetContainer.clientWidth
        }; // pixel values
        var eventOffsetX = event.offsetX || event.layerX;
        var eventOffsetY = event.offsetY || event.layerY;
        this.desiredPosition = { top: this.startRender.top, left: this.startRender.left };
        this.moverOffset = new GridRectangle({
            top: eventOffsetY + this.el.nativeElement.offsetTop || 0,
            left: eventOffsetX + this.el.nativeElement.offsetLeft || 0
        });
        this.gridPositions = this.gridCmp.getGridRectangle();
        this.cellHeight = (this.gridCmp.grid.cellSize.height / 100) * this.gridPositions.height;
        this.cellWidth = (this.gridCmp.grid.cellSize.width / 100) * this.gridPositions.width;
        this.enableDrag = this.widgetCmp.getConfig().getId();
    };
    NgxWidgetMoverDirective.prototype.onUp = function (event) {
        if (this.enableDrag === this.widgetCmp.getConfig().getId()) {
            event.preventDefault();
            var finalPos = this.determineFinalPos(this.startPosition, this.desiredPosition, this.startRender, this.cellHeight, this.cellWidth);
            this.gridCmp.resetHighlights();
            this.renderer.removeClass(this.widgetCmp.getEl().nativeElement, 'wg-moving');
            this.widgetCmp.position = finalPos;
            this.gridCmp.updateWidget(this.widgetCmp);
            this.enableDrag = null;
        }
    };
    NgxWidgetMoverDirective.prototype.onMove = function (event) {
        if (this.enableDrag === this.widgetCmp.getConfig().getId()) {
            event.preventDefault();
            var eventClientX = event.clientX, eventClientY = event.clientY;
            var startRender = this.startRender;
            var gridDimensions = this.gridPositions;
            var desiredPosition = this.desiredPosition;
            // normalize the drag position
            var dragPositionX = Math.round(eventClientX) - gridDimensions.left, dragPositionY = Math.round(eventClientY) - gridDimensions.top;
            desiredPosition.top = Math.min(Math.max(dragPositionY - this.moverOffset.top, 0), gridDimensions.height - startRender.height - 1);
            desiredPosition.left = Math.min(Math.max(dragPositionX - this.moverOffset.left, 0), gridDimensions.width - startRender.width - 1);
            var currentFinalPos = this.determineFinalPos(this.startPosition, this.desiredPosition, this.startRender, this.cellHeight, this.cellWidth);
            this.gridCmp.highlightArea(currentFinalPos);
            this.renderer.setStyle(this.widgetCmp.getEl().nativeElement, 'top', desiredPosition.top + 'px');
            this.renderer.setStyle(this.widgetCmp.getEl().nativeElement, 'left', desiredPosition.left + 'px');
        }
    };
    NgxWidgetMoverDirective.prototype.getAnchor = function (val, max) {
        return (val % max) > (max / 2) ? val + Math.floor(max) : val;
    };
    NgxWidgetMoverDirective.prototype.determineFinalPos = function (startPos, desiredPos, startRender, cellHt, cellWd) {
        var this$1 = this;

        if (startRender.top === desiredPos.top && startRender.left === desiredPos.left) {
            return startPos;
        }
        var anchorTop = this.getAnchor(desiredPos.top, cellHt), anchorLeft = this.getAnchor(desiredPos.left, cellWd);
        var movedDown = anchorTop >= startRender.top, movedRight = anchorLeft >= startRender.left;
        var desiredFinalPosition = this.gridCmp.rasterizeCoords(anchorLeft, anchorTop);
        var path = new PathIterator(desiredFinalPosition, startPos);
        while (path.hasNext()) {
            var currPos = path.next();
            var targetArea = new GridRectangle({
                top: currPos.top,
                left: currPos.left,
                height: startPos.height,
                width: startPos.width
            });
            var options = {
                excludedArea: startPos,
                fromBottom: movedDown,
                fromRight: movedRight
            };
            if (!this$1.gridCmp.isAreaObstructed(targetArea, options)) {
                // try to get closer to the desired position by leaving the original path
                var top_1 = targetArea.top, left = targetArea.left, height = targetArea.height, width = targetArea.width;
                if (desiredFinalPosition.top < top_1) {
                    var checkRect = new GridRectangle({ top: top_1 - 1, left: left, height: height, width: width }), isRectVacant = !this$1.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.top <= targetArea.top - 1 && isRectVacant) {
                        targetArea.top--;
                    }
                }
                else if (desiredFinalPosition.top > top_1) {
                    var checkRect = new GridRectangle({ top: top_1 + 1, left: left, height: height, width: width }), isRectVacant = !this$1.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.top >= targetArea.top + 1 && isRectVacant) {
                        targetArea.top++;
                    }
                }
                top_1 = targetArea.top;
                if (desiredFinalPosition.left < left) {
                    var checkRect = new GridRectangle({ top: top_1, left: left - 1, height: height, width: width }), isRectVacant = !this$1.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.left <= targetArea.left - 1 && isRectVacant) {
                        targetArea.left--;
                    }
                }
                else if (desiredFinalPosition.left > left) {
                    var checkRect = new GridRectangle({ top: top_1, left: left + 1, height: height, width: width }), isRectVacant = !this$1.gridCmp.isAreaObstructed(checkRect, options);
                    while (desiredFinalPosition.left >= targetArea.left + 1 && isRectVacant) {
                        targetArea.left++;
                    }
                }
                return new GridRectangle(targetArea);
            }
        }
        return new GridRectangle(startPos);
    };
    NgxWidgetMoverDirective.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: '[ngx-widget-mover]'
                } ] } ];
    /** @nocollapse */
    NgxWidgetMoverDirective.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer2, },
        { type: NgxWidgetGridComponent, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return NgxWidgetGridComponent; }) ] } ] },
        { type: NgxWidgetComponent, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return NgxWidgetComponent; }) ] } ] } ]; };
    NgxWidgetMoverDirective.propDecorators = {
        'onDown': [{ type: _angular_core.HostListener, args: ['mousedown', ['$event'] ] } ],
        'onUp': [{ type: _angular_core.HostListener, args: ['window:mouseup', ['$event'] ] } ],
        'onMove': [{ type: _angular_core.HostListener, args: ['window:mousemove', ['$event'] ] } ],
    };
    return NgxWidgetMoverDirective;
}());

var MIN_HEIGHT = 42;
var MIN_WIDTH = 42;
var NgxWidgetResizerDirective = /** @class */ (function () {
    function NgxWidgetResizerDirective(el, renderer, gridCmp, widgetCmp) {
        this.el = el;
        this.renderer = renderer;
        this.gridCmp = gridCmp;
        this.widgetCmp = widgetCmp;
        this.moveUpAllowed = false;
        this.moveDownAllowed = false;
        this.moveLeftAllowed = false;
        this.moveRightAllowed = false;
        this.enableDrag = null;
        this.parentContainer = this.el.nativeElement.parentElement;
    }
    Object.defineProperty(NgxWidgetResizerDirective.prototype, "resizeDirection", {
        get: function () {
            return this._resizeDirection;
        },
        set: function (dir) {
            this._resizeDirection = dir;
            this.moveUpAllowed = false;
            this.moveDownAllowed = false;
            this.moveLeftAllowed = false;
            this.moveRightAllowed = false;
            switch (dir) {
                case RESIZE_DIRECTIONS.top:
                    this.moveUpAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.left:
                    this.moveLeftAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.bottom:
                    this.moveDownAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.right:
                    this.moveRightAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.topLeft:
                    this.moveUpAllowed = true;
                    this.moveLeftAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.topRight:
                    this.moveUpAllowed = true;
                    this.moveRightAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.bottomLeft:
                    this.moveDownAllowed = true;
                    this.moveLeftAllowed = true;
                    break;
                case RESIZE_DIRECTIONS.bottomRight:
                    this.moveDownAllowed = true;
                    this.moveRightAllowed = true;
                    break;
                default:
            }
        },
        enumerable: true,
        configurable: true
    });
    NgxWidgetResizerDirective.prototype.onDown = function (event) {
        event.preventDefault();
        this.enableDrag = this.widgetCmp.getConfig().getId();
        this.renderer.addClass(this.widgetCmp.getEl().nativeElement, 'wg-resizing');
        this.renderer.addClass(this.el.nativeElement, 'dragging');
        this.startPosition = this.gridCmp.getWidgetPosition(this.widgetCmp);
        this.startPosition.bottom = this.startPosition.top + this.startPosition.height - 1;
        this.startPosition.right = this.startPosition.left + this.startPosition.width - 1;
        this.startRender = {
            top: Math.ceil(this.widgetCmp.getEl().nativeElement.offsetTop),
            left: Math.ceil(this.widgetCmp.getEl().nativeElement.offsetLeft),
            height: Math.floor(this.parentContainer.offsetHeight),
            width: Math.floor(this.parentContainer.offsetWidth)
        }; // pixel values
        this.startRender.bottom = this.startRender.top + this.startRender.height;
        this.startRender.right = this.startRender.left + this.startRender.width;
        var eventOffsetX = event.offsetX || event.layerX;
        var eventOffsetY = event.offsetY || event.layerY;
        this.delta = { top: 0, right: 0, bottom: 0, left: 0 };
        this.draggerOffset = {
            top: eventOffsetY,
            left: eventOffsetX,
            bottom: eventOffsetY - this.el.nativeElement.offsetHeight,
            right: eventOffsetX - this.el.nativeElement.offsetWidth
        };
        this.gridPositions = this.gridCmp.getGridRectangle();
    };
    NgxWidgetResizerDirective.prototype.onMove = function (event) {
        if (this.enableDrag === this.widgetCmp.getConfig().getId()) {
            event.preventDefault();
            var eventClientX = event.clientX, eventClientY = event.clientY;
            var gridDims = this.gridPositions;
            var startRender = this.startRender;
            // normalize the drag position
            var dragPositionX = Math.round(eventClientX) - gridDims.left, dragPositionY = Math.round(eventClientY) - gridDims.top;
            var delta = this.delta;
            if (this.moveUpAllowed) {
                delta.top = Math.min(Math.max(dragPositionY - this.draggerOffset.top, 0), gridDims.height) - startRender.top;
                delta.top = Math.min(delta.top, startRender.height - MIN_HEIGHT);
            }
            else if (this.moveDownAllowed) {
                delta.bottom = startRender.bottom - Math.min(Math.max(dragPositionY - this.draggerOffset.bottom, 0), gridDims.height);
                delta.bottom = Math.min(delta.bottom, startRender.height - MIN_HEIGHT);
            }
            if (this.moveLeftAllowed) {
                delta.left = Math.min(Math.max(dragPositionX - this.draggerOffset.left, 0), gridDims.width) - startRender.left;
                delta.left = Math.min(delta.left, startRender.width - MIN_WIDTH);
            }
            else if (this.moveRightAllowed) {
                delta.right = startRender.right - Math.min(Math.max(dragPositionX - this.draggerOffset.right, 0), gridDims.width);
                delta.right = Math.min(delta.right, startRender.width - MIN_WIDTH);
            }
            var currentFinalPos = this.determineFinalPos();
            this.gridCmp.highlightArea(currentFinalPos);
            this.renderer.setStyle(this.parentContainer, 'top', this.delta.top + 'px');
            this.renderer.setStyle(this.parentContainer, 'left', this.delta.left + 'px');
            this.renderer.setStyle(this.parentContainer, 'bottom', this.delta.bottom + 'px');
            this.renderer.setStyle(this.parentContainer, 'right', this.delta.right + 'px');
        }
    };
    NgxWidgetResizerDirective.prototype.onUp = function (event) {
        if (this.enableDrag === this.widgetCmp.getConfig().getId()) {
            event.preventDefault();
            this.el.nativeElement.setAttribute('draggable', false);
            this.renderer.removeClass(this.el.nativeElement, 'dragging');
            this.renderer.removeClass(this.widgetCmp.getEl().nativeElement, 'wg-resizing');
            this.enableDrag = null;
            this.widgetCmp.position = this.determineFinalPos();
            this.gridCmp.updateWidget(this.widgetCmp);
            this.gridCmp.resetHighlights();
            // reset style
            this.renderer.removeClass(this.widgetCmp.getEl().nativeElement, 'wg-resizing');
            this.renderer.removeClass(this.el.nativeElement, 'dragging');
            this.renderer.setStyle(this.parentContainer, 'top', '');
            this.renderer.setStyle(this.parentContainer, 'left', '');
            this.renderer.setStyle(this.parentContainer, 'bottom', '');
            this.renderer.setStyle(this.parentContainer, 'right', '');
        }
    };
    NgxWidgetResizerDirective.prototype.findCollision = function (start, end, val, reverse) {
        var this$1 = this;

        if (reverse === void 0) { reverse = false; }
        var foundCollision = false;
        for (var i = start; i <= end; i++) {
            var checker = reverse ? this$1.gridCmp.isPointObstructed(i, val) : this$1.gridCmp.isPointObstructed(val, i);
            if (checker) {
                foundCollision = true;
                break;
            }
        }
        return foundCollision;
    };
    NgxWidgetResizerDirective.prototype.determineFinalPos = function () {
        var this$1 = this;

        var finalPos = new GridRectangle();
        var startRender = this.startRender;
        var delta = this.delta;
        var requestedStartPoint = this.gridCmp.rasterizeCoords(startRender.left + delta.left + 1, startRender.top + delta.top + 1), requestedEndPoint = this.gridCmp.rasterizeCoords(startRender.right - delta.right - 1, startRender.bottom - delta.bottom - 1);
        var requestedPos = {
            top: requestedStartPoint.top,
            right: requestedEndPoint.left,
            bottom: requestedEndPoint.top,
            left: requestedStartPoint.left
        };
        // determine a suitable final position (one that is not obstructed)
        var foundCollision;
        var start = Math.max(this.startPosition.left, requestedPos.left);
        var end = Math.min(this.startPosition.right, requestedPos.right);
        if (this.moveUpAllowed && requestedPos.top < this.startPosition.top) {
            finalPos.top = this.startPosition.top;
            while (finalPos.top > requestedPos.top) {
                // check whether adding another row would cause any conflict
                foundCollision = this$1.findCollision(start, end, finalPos.top - 1);
                if (foundCollision) {
                    break;
                }
                finalPos.top--; // add row
            }
        }
        else if (this.moveDownAllowed && requestedPos.bottom > this.startPosition.bottom) {
            finalPos.bottom = this.startPosition.bottom;
            while (finalPos.bottom < requestedPos.bottom) {
                foundCollision = this$1.findCollision(start, end, finalPos.bottom + 1);
                if (foundCollision) {
                    break;
                }
                finalPos.bottom++;
            }
        }
        finalPos.top = finalPos.top || requestedPos.top;
        finalPos.bottom = finalPos.bottom || requestedPos.bottom;
        if (this.moveLeftAllowed && requestedPos.left < this.startPosition.left) {
            finalPos.left = this.startPosition.left;
            while (finalPos.left > requestedPos.left) {
                // check whether adding another column would cause any conflict
                foundCollision = this$1.findCollision(finalPos.top, finalPos.bottom, finalPos.left - 1, true);
                if (foundCollision) {
                    break;
                }
                finalPos.left--; // add column
            }
        }
        else if (this.moveRightAllowed && requestedPos.right > this.startPosition.right) {
            finalPos.right = this.startPosition.right;
            while (finalPos.right < requestedPos.right) {
                foundCollision = this$1.findCollision(finalPos.top, finalPos.bottom, finalPos.right + 1, true);
                if (foundCollision) {
                    break;
                }
                finalPos.right++;
            }
        }
        finalPos.right = finalPos.right || requestedPos.right;
        finalPos.left = finalPos.left || requestedPos.left;
        finalPos.height = finalPos.bottom - finalPos.top + 1;
        finalPos.width = finalPos.right - finalPos.left + 1;
        return finalPos;
    };
    NgxWidgetResizerDirective.decorators = [
        { type: _angular_core.Directive, args: [{
                    selector: '[ngx-widget-resizer]'
                } ] } ];
    /** @nocollapse */
    NgxWidgetResizerDirective.ctorParameters = function () { return [
        { type: _angular_core.ElementRef, },
        { type: _angular_core.Renderer2, },
        { type: NgxWidgetGridComponent, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return NgxWidgetGridComponent; }) ] } ] },
        { type: NgxWidgetComponent, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return NgxWidgetComponent; }) ] } ] } ]; };
    NgxWidgetResizerDirective.propDecorators = {
        'resizeDirection': [{ type: _angular_core.Input, args: ['ngx-widget-resizer' ] } ],
        'onDown': [{ type: _angular_core.HostListener, args: ['mousedown', ['$event'] ] } ],
        'onMove': [{ type: _angular_core.HostListener, args: ['window:mousemove', ['$event'] ] } ],
        'onUp': [{ type: _angular_core.HostListener, args: ['window:mouseup', ['$event'] ] } ],
    };
    return NgxWidgetResizerDirective;
}());

var NgxWidgetGridModule = /** @class */ (function () {
    function NgxWidgetGridModule() {
    }
    NgxWidgetGridModule.forRoot = function () {
        return {
            ngModule: NgxWidgetGridModule,
            providers: []
        };
    };
    NgxWidgetGridModule.forChild = function () {
        return {
            ngModule: NgxWidgetGridModule,
            providers: []
        };
    };
    NgxWidgetGridModule.decorators = [
        { type: _angular_core.NgModule, args: [{
                    imports: [_angular_common.CommonModule],
                    declarations: [
                        NgxGridOverlayComponent,
                        NgxWidgetComponent,
                        NgxWidgetGridComponent,
                        NgxWidgetMoverDirective,
                        NgxWidgetResizerDirective
                    ],
                    providers: [],
                    exports: [
                        NgxWidgetComponent,
                        NgxWidgetGridComponent
                    ]
                } ] } ];
    /** @nocollapse */
    NgxWidgetGridModule.ctorParameters = function () { return []; };
    return NgxWidgetGridModule;
}());

exports.NgxWidgetGridModule = NgxWidgetGridModule;

Object.defineProperty(exports, '__esModule', { value: true });

})));
