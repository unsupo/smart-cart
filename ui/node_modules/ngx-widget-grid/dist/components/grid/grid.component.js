import { Component, ContentChildren, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';
import { Grid } from '../../models/Grid.model';
import { NgxWidgetComponent } from '../widget/widget.component';
import { GridRenderer } from '../../models/GridRenderer.model';
import { GridRectangle } from '../../models/GridRectangle.model';
var NgxWidgetGridComponent = /** @class */ (function () {
    function NgxWidgetGridComponent(el, _renderer) {
        this.el = el;
        this._renderer = _renderer;
        this.showGrid = false;
        this._highlightNextPosition = false;
        this.clickThrough = false;
        this.widgetPositionChangeEmitter = new EventEmitter();
        this.gridFullEmitter = new EventEmitter();
        this.gridAlreadyFull = false;
        this.grid = new Grid(this.rows, this.columns);
        this.gridRenderer = new GridRenderer(this.grid);
    }
    Object.defineProperty(NgxWidgetGridComponent.prototype, "rows", {
        get: function () {
            return this._rows;
        },
        set: function (rows) {
            this._rows = rows;
            this.updateGridSize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxWidgetGridComponent.prototype, "columns", {
        get: function () {
            return this._columns;
        },
        set: function (cols) {
            this._columns = cols;
            this.updateGridSize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxWidgetGridComponent.prototype, "highlightNextPosition", {
        get: function () {
            return this._highlightNextPosition;
        },
        set: function (highlightNext) {
            this._highlightNextPosition = highlightNext;
            if (highlightNext) {
                this.updateNextPositionHighlight();
            }
            else {
                this.resetHighlights();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgxWidgetGridComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.refreshWidgets();
        this.widgetComponents.changes.subscribe(function () {
            _this.clearGrid();
            _this.refreshWidgets();
        });
    };
    NgxWidgetGridComponent.prototype.refreshWidgets = function () {
        var _this = this;
        this.widgetComponents.forEach(function (widget) {
            if (!_this.hasWidget(widget)) {
                _this.addWidget(widget, true);
            }
            else {
            }
        });
        this.updateRendering();
    };
    NgxWidgetGridComponent.prototype.hasWidget = function (widget) {
        return this.grid.hasWidget(widget.getConfig());
    };
    NgxWidgetGridComponent.prototype.addWidget = function (widget, deferredRender) {
        this.grid.add(widget.getConfig());
        if (!deferredRender) {
            this.updateRendering();
        }
    };
    NgxWidgetGridComponent.prototype.clearGrid = function () {
        this.grid.removeAll();
    };
    NgxWidgetGridComponent.prototype.updateGridSize = function () {
        var columns = this.columns;
        var rows = this.rows;
        if (this.grid.columns !== columns || this.grid.rows !== rows) {
            this.grid.resize(rows, columns);
            this.updateRendering();
        }
    };
    NgxWidgetGridComponent.prototype.updateRendering = function () {
        var _this = this;
        this.gridRenderer.render(this.grid, this.emitUpdatePosition.bind(this));
        this.updateNextPositionHighlight();
        // TODO: retrieve all widgets and call their updateRendering
        if (this.widgetComponents) {
            this.widgetComponents.forEach(function (widget) {
                _this.updateWidget(widget);
            });
        }
    };
    NgxWidgetGridComponent.prototype.getGridRectangle = function () {
        var gridContainer = this.el.nativeElement;
        // c.f. jQuery#offset: https://github.com/jquery/jquery/blob/2d715940b9b6fdeed005cd006c8bf63951cf7fb2/src/offset.js#L93-105
        var rect = gridContainer.getBoundingClientRect();
        if (rect.width || rect.height || gridContainer.getClientRects().length) {
            var doc = gridContainer.ownerDocument;
            var docElem = doc.documentElement;
            return new GridRectangle({
                top: rect.top + window.pageYOffset - docElem.clientTop,
                left: rect.left + window.pageXOffset - docElem.clientLeft,
                height: rect.height,
                width: rect.width
            });
        }
        return new GridRectangle({ top: 0, left: 0, height: 0, width: 0 });
    };
    NgxWidgetGridComponent.prototype.rasterizeCoords = function (x, y) {
        return this.gridRenderer.rasterizeCoords(x, y, this.el.nativeElement.clientWidth, this.el.nativeElement.clientHeight);
    };
    NgxWidgetGridComponent.prototype.updateWidget = function (widget) {
        var config = widget.getConfig();
        var newPosition = config.position;
        var el = widget.getEl();
        this.gridRenderer.setWidgetPosition(config.getId(), newPosition);
        var widgetStyles = this.getWidgetStyle(widget);
        for (var style in widgetStyles) {
            if (widgetStyles.hasOwnProperty(style)) {
                this._renderer.setStyle(el.nativeElement, style, widgetStyles[style]);
            }
        }
        this.emitUpdatePosition(config);
        this.assessAvailableGridSpace();
    };
    NgxWidgetGridComponent.prototype.getWidgetPosition = function (widget) {
        return this.gridRenderer.getWidgetPosition(widget.getConfig());
    };
    NgxWidgetGridComponent.prototype.getWidgetStyle = function (widget) {
        return this.gridRenderer.getStyle(widget.getConfig().getId());
    };
    NgxWidgetGridComponent.prototype.isPointObstructed = function (i, j) {
        return this.gridRenderer ? this.gridRenderer.isObstructed(i, j) : true;
    };
    NgxWidgetGridComponent.prototype.isAreaObstructed = function (area, options) {
        return this.gridRenderer ? this.gridRenderer.isAreaObstructed(area, options) : true;
    };
    NgxWidgetGridComponent.prototype.highlightArea = function (area) {
        var _this = this;
        if (area.top && area.left && area.height && area.width) {
            setTimeout(function () {
                _this.highlightedArea = area;
            });
        }
    };
    NgxWidgetGridComponent.prototype.updateNextPositionHighlight = function () {
        if (this.highlightNextPosition) {
            this.highlightedArea = this.gridRenderer.getNextPosition();
        }
    };
    NgxWidgetGridComponent.prototype.getNextPosition = function () {
        return this.gridRenderer.getNextPosition();
    };
    NgxWidgetGridComponent.prototype.getPositions = function () {
        return this.grid.widgets;
    };
    NgxWidgetGridComponent.prototype.resetHighlights = function () {
        var _this = this;
        setTimeout(function () {
            _this.highlightedArea = null;
        });
    };
    NgxWidgetGridComponent.prototype.emitUpdatePosition = function (widget) {
        this.widgetPositionChangeEmitter.emit({
            index: this.getWidgetIndex(widget),
            newPosition: widget.position
        });
    };
    NgxWidgetGridComponent.prototype.getWidgetIndex = function (widgetConfig) {
        for (var i = this.grid.widgets.length - 1; i >= 0; i--) {
            if (this.grid.widgets[i].getId() === widgetConfig.getId()) {
                return i;
            }
        }
        return -1;
    };
    NgxWidgetGridComponent.prototype.assessAvailableGridSpace = function () {
        var gridHasSpaceLeft = this.gridRenderer.hasSpaceLeft();
        if (this.gridAlreadyFull) {
            if (gridHasSpaceLeft) {
                this.gridFullEmitter.emit(false);
                this.gridAlreadyFull = false;
            }
            else {
                /*No change to grid status. was and still is full*/
            }
        }
        else {
            if (!gridHasSpaceLeft) {
                this.gridFullEmitter.emit(true);
                this.gridAlreadyFull = true;
            }
            else {
                /*No change to grid status. had and still has available space*/
            }
        }
    };
    NgxWidgetGridComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-widget-grid',
                    styles: ["\n                 :host{height:100%;width:100%;position:absolute;overflow:hidden}\n               "],
                    template: "\n                 <ngx-grid-overlay [showGrid]=\"showGrid\"\n                                   [renderer]=\"gridRenderer\"\n                                   [highlight]=\"highlightedArea\"\n                                   [cols]=\"columns\"\n                                   [rows]=\"rows\">\n                 </ngx-grid-overlay>\n                 <div class=\"wg-grid-widgets\">\n                     <ng-content></ng-content>\n                 </div>\n               "
                },] },
    ];
    /** @nocollapse */
    NgxWidgetGridComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    NgxWidgetGridComponent.propDecorators = {
        'rows': [{ type: Input },],
        'columns': [{ type: Input },],
        'showGrid': [{ type: Input },],
        'highlightNextPosition': [{ type: Input },],
        'clickThrough': [{ type: Input },],
        'widgetPositionChangeEmitter': [{ type: Output, args: ['widgetPositionChange',] },],
        'gridFullEmitter': [{ type: Output, args: ['gridFull',] },],
        'widgetComponents': [{ type: ContentChildren, args: [NgxWidgetComponent,] },],
    };
    return NgxWidgetGridComponent;
}());
export { NgxWidgetGridComponent };
//# sourceMappingURL=grid.component.js.map