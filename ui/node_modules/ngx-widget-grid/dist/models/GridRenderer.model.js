import { Grid } from './Grid.model';
import { GridPoint } from './GridPoint.model';
import { Utils } from '../Utils';
import { GridRectangle } from './GridRectangle.model';
var GridRenderer = /** @class */ (function () {
    function GridRenderer(grid) {
        this.positions = {};
        this.obstructions = [];
        this.grid = grid || new Grid();
    }
    Object.defineProperty(GridRenderer.prototype, "grid", {
        get: function () {
            return this._grid;
        },
        set: function (grid) {
            this._grid = grid;
            this.positions = {};
            this.cachedNextPosition = undefined;
            this.obstructions = [];
            for (var i = 0; i < grid.rows * grid.columns; i++) {
                this.obstructions[i] = 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    GridRenderer.prototype.rasterizeCoords = function (left, top, gridWidth, gridHeight) {
        left = Math.min(Math.max(left, 0), gridWidth - 1);
        top = Math.min(Math.max(top, 0), gridHeight - 1);
        var x = Math.floor(top / gridHeight * this.grid.rows) + 1, y = Math.floor(left / gridWidth * this.grid.columns) + 1;
        return new GridPoint(x, y);
    };
    GridRenderer.prototype.getWidgetIdAt = function (i, j) {
        for (var widgetId in this.positions) {
            if (this.positions.hasOwnProperty(widgetId)) {
                var position = this.positions[widgetId];
                if (position.top <= i && i <= (position.top + position.height - 1) &&
                    position.left <= j && j <= (position.left + position.width - 1)) {
                    return widgetId;
                }
            }
        }
        return null;
    };
    GridRenderer.prototype.getWidgetPosition = function (widget) {
        return this.positions[widget.getId()];
    };
    GridRenderer.prototype.setWidgetPosition = function (widgetId, newPosition) {
        var currPosition = this.positions[widgetId];
        if (currPosition) {
            this.setObstructionValues(currPosition, 0);
        }
        newPosition = new GridRectangle({
            top: Utils.isNumber(newPosition.top) ? newPosition.top : currPosition.top,
            left: Utils.isNumber(newPosition.left) ? newPosition.left : currPosition.left,
            width: Utils.isNumber(newPosition.width) ? newPosition.width : currPosition.width,
            height: Utils.isNumber(newPosition.height) ? newPosition.height : currPosition.height,
        });
        this.positions[widgetId] = newPosition;
        this.setObstructionValues(this.positions[widgetId], 1);
        this.cachedNextPosition = undefined;
    };
    GridRenderer.prototype.hasSpaceLeft = function () {
        for (var _i = 0, _a = this.obstructions; _i < _a.length; _i++) {
            var obstruction = _a[_i];
            if (!obstruction) {
                return true;
            }
        }
        return false;
    };
    GridRenderer.prototype.getNextPosition = function () {
        if (this.cachedNextPosition !== undefined) {
            return this.cachedNextPosition;
        }
        if (!this.hasSpaceLeft()) {
            return null;
        }
        var maxPosition = this.findLargestEmptyArea();
        this.cachedNextPosition = maxPosition;
        return maxPosition;
    };
    GridRenderer.prototype.isObstructed = function (i, j, excludedArea) {
        // obstructed if (i, j) exceeds the grid's regular non-expanding boundaries
        if (i < 1 || j < 1 || j > this.grid.columns || i > this.grid.rows) {
            return true;
        }
        var bottom = excludedArea && excludedArea.top + excludedArea.height - 1;
        var right = excludedArea && excludedArea.left + excludedArea.width - 1;
        // pass if (i, j) is within the excluded area, if any
        if (excludedArea &&
            excludedArea.top <= i &&
            i <= bottom &&
            excludedArea.left <= j &&
            j <= right) {
            return false;
        }
        return this._isObstructed(i, j);
    };
    GridRenderer.prototype._isObstructed = function (i, j) {
        return this.obstructions[(i - 1) * this.grid.columns + (j - 1)] === 1;
    };
    GridRenderer.prototype.isAreaObstructed = function (area, options) {
        if (!area) {
            return false;
        }
        options = Utils.isObject(options) ? options : {};
        var top = area.top, left = area.left, bottom = area.bottom || area.top + area.height - 1, right = area.right || area.left + area.width - 1;
        if (!Utils.isNumber(top) || !Utils.isNumber(left) || !Utils.isNumber(bottom) || !Utils.isNumber(right)) {
            return false;
        }
        var verticalStart = options.fromBottom ? bottom : top, verticalStep = options.fromBottom ? -1 : 1, verticalEnd = (options.fromBottom ? top : bottom) + verticalStep;
        var horizontalStart = options.fromRight ? right : left, horizontalStep = options.fromRight ? -1 : 1, horizontalEnd = (options.fromRight ? left : right) + horizontalStep;
        for (var i = verticalStart; i !== verticalEnd; i += verticalStep) {
            for (var j = horizontalStart; j !== horizontalEnd; j += horizontalStep) {
                if (this.isObstructed(i, j, options.excludedArea)) {
                    return true;
                }
            }
        }
        return false;
    };
    GridRenderer.prototype.getStyle = function (widgetId) {
        var render = this.positions[widgetId];
        if (!render) {
            return { display: 'none' };
        }
        return {
            top: ((render.top - 1) * this.grid.cellSize.height).toString() + '%',
            height: (render.height * this.grid.cellSize.height).toString() + '%',
            left: ((render.left - 1) * this.grid.cellSize.width).toString() + '%',
            width: (render.width * this.grid.cellSize.width).toString() + '%'
        };
    };
    GridRenderer.prototype.setObstructionValues = function (area, value) {
        for (var i = area.top - 1; i < area.top + area.height - 1; i++) {
            for (var j = area.left - 1; j < area.left + area.width - 1; j++) {
                this.obstructions[i * this.grid.columns + j] = value;
            }
        }
    };
    GridRenderer.prototype.findLargestEmptyArea = function () {
        var maxArea = null, currMaxArea = null, maxSurfaceArea = 0, currMaxSurfaceArea = 0;
        for (var i = 1; i <= this.grid.rows; i++) {
            for (var j = 1; j <= this.grid.columns; j++) {
                if (this._isObstructed(i, j)) {
                    continue;
                }
                var currAreaLimit = (this.grid.rows - i + 1) * (this.grid.columns - j + 1);
                if (currAreaLimit < maxSurfaceArea) {
                    break;
                }
                currMaxArea = this._findLargestEmptyAreaFrom(new GridPoint(i, j));
                currMaxSurfaceArea = currMaxArea.getSurfaceArea();
                if (currMaxSurfaceArea > maxSurfaceArea) {
                    maxSurfaceArea = currMaxSurfaceArea;
                    maxArea = currMaxArea;
                }
            }
        }
        return maxArea;
    };
    GridRenderer.prototype._findLargestEmptyAreaFrom = function (start) {
        if (!Utils.isDefined(this.grid) || !Utils.isNumber(this.grid.columns) || !Utils.isNumber(this.grid.rows)) {
            return null;
        }
        var maxArea = null, maxSurfaceArea = 0, endColumn = this.grid.columns;
        for (var i = start.top; i <= this.grid.rows; i++) {
            for (var j = start.left; j <= endColumn; j++) {
                if (this._isObstructed(i, j)) {
                    endColumn = j - 1;
                    continue;
                }
                var currHeight = (i - start.top + 1), currWidth = (j - start.left + 1), currSurfaceArea = currHeight * currWidth;
                if (currSurfaceArea > maxSurfaceArea) {
                    maxSurfaceArea = currSurfaceArea;
                    maxArea = new GridRectangle({
                        top: start.top,
                        left: start.left,
                        width: currWidth,
                        height: currHeight
                    });
                }
            }
        }
        return maxArea;
    };
    GridRenderer.prototype.render = function (grid, emitWidgetPositionUpdated) {
        var _this = this;
        this.grid = grid;
        var widgets = this.grid && this.grid.widgets ? this.grid.widgets : [];
        var unpositionedWidgets = [];
        widgets.forEach(function (widget) {
            var position = widget.position;
            if (position.width * position.height === 0 ||
                _this.isAreaObstructed(position)) {
                unpositionedWidgets.push(widget);
            }
            else {
                _this.setWidgetPosition(widget.getId(), position);
            }
        });
        unpositionedWidgets.forEach(function (widget) {
            var nextPosition = _this.getNextPosition();
            if (nextPosition !== null) {
                widget.position = nextPosition;
                _this.setWidgetPosition(widget.getId(), nextPosition);
            }
            else {
                widget.position = new GridRectangle();
                _this.setWidgetPosition(widget.getId(), new GridRectangle());
            }
            if (emitWidgetPositionUpdated) {
                emitWidgetPositionUpdated(widget);
            }
        });
    };
    return GridRenderer;
}());
export { GridRenderer };
//# sourceMappingURL=GridRenderer.model.js.map