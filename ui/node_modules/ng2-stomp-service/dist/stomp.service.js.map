{"version":3,"names":[],"mappings":"","sources":["stomp.service.js"],"sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nexports.__esModule = true;\nvar core_1 = require(\"@angular/core\");\nvar Stomp = require(\"stompjs\");\nvar SockJS = require(\"sockjs-client\");\nvar StompService = (function () {\n    function StompService() {\n        var _this = this;\n        this.config = null;\n        this.queuePromises = [];\n        /**\n         * Successfull connection to server\n         */\n        this.onConnect = function (frame) {\n            _this.status = 'CONNECTED';\n            _this.resolveConPromise();\n            _this.timer = null;\n            //console.log('Connected: ' + frame);\n        };\n        /**\n         * Unsuccessfull connection to server\n         */\n        this.onError = function (error) {\n            console.error(\"Error: \" + error);\n            // Check error and try reconnect\n            if (error.indexOf('Lost connection') !== -1) {\n                if (_this.config.debug) {\n                    console.log('Reconnecting...');\n                }\n                _this.timer = setTimeout(function () {\n                    _this.startConnect();\n                }, _this.config.recTimeout || 5000);\n            }\n        };\n        this.status = 'CLOSED';\n        //Create promise\n        this.disconnectPromise = new Promise(function (resolve, reject) { return _this.resolveDisConPromise = resolve; });\n    }\n    /**\n     * Configure\n     */\n    StompService.prototype.configure = function (config) {\n        this.config = config;\n    };\n    /**\n     * Try to establish connection to server\n     */\n    StompService.prototype.startConnect = function () {\n        var _this = this;\n        if (this.config === null) {\n            throw Error('Configuration required!');\n        }\n        this.status = 'CONNECTING';\n        //Prepare Client\n        this.socket = new SockJS(this.config.host);\n        this.stomp = Stomp.over(this.socket);\n        this.stomp.heartbeat.outgoing = this.config.heartbeatOut || 10000;\n        this.stomp.heartbeat.incoming = this.config.heartbeatIn || 10000;\n        //Debuging connection\n        if (this.config.debug) {\n            this.stomp.debug = function (str) {\n                console.log(str);\n            };\n        }\n        else {\n            this.stomp.debug = false;\n        }\n        //Connect to server\n        this.stomp.connect(this.config.headers || {}, this.onConnect, this.onError);\n        return new Promise(function (resolve, reject) { return _this.resolveConPromise = resolve; });\n    };\n    /**\n     * Subscribe\n     */\n    StompService.prototype.subscribe = function (destination, callback, headers) {\n        headers = headers || {};\n        return this.stomp.subscribe(destination, function (response) {\n            var message = JSON.parse(response.body);\n            var headers = response.headers;\n            callback(message, headers);\n        }, headers);\n    };\n    /**\n     * Unsubscribe\n     */\n    StompService.prototype.unsubscribe = function (subscription) {\n        subscription.unsubscribe();\n    };\n    /**\n     * Send\n     */\n    StompService.prototype.send = function (destination, body, headers) {\n        var message = JSON.stringify(body);\n        headers = headers || {};\n        this.stomp.send(destination, headers, message);\n    };\n    /**\n     * Disconnect stomp\n     */\n    StompService.prototype.disconnect = function () {\n        var _this = this;\n        this.stomp.disconnect(function () { _this.resolveDisConPromise(); _this.status = 'CLOSED'; });\n        return this.disconnectPromise;\n    };\n    /**\n     * After specified subscription\n     */\n    StompService.prototype.after = function (name) {\n        var _this = this;\n        this.nameCheck(name);\n        if (this.config.debug)\n            console.log('checking ' + name + ' queue ...');\n        var checkQueue = setInterval(function () {\n            if (_this.config.queue[name]) {\n                clearInterval(checkQueue);\n                _this.queuePromises[name]();\n                if (_this.config.debug)\n                    console.log('queue ' + name + ' <<< has been complated');\n                return false;\n            }\n        }, this.config.queueCheckTime || 100);\n        if (!this.queuePromises[name + 'promice']) {\n            this.queuePromises[name + 'promice'] = new Promise(function (resolve, reject) { return _this.queuePromises[name] = resolve; });\n        }\n        return this.queuePromises[name + 'promice'];\n    };\n    /**\n     * Done specified subscription\n     */\n    StompService.prototype.done = function (name) {\n        this.nameCheck(name);\n        this.config.queue[name] = true;\n    };\n    /**\n     * Turn specified subscription on pending mode\n     */\n    StompService.prototype.pending = function (name) {\n        this.nameCheck(name);\n        this.config.queue[name] = false;\n        if (this.config.debug)\n            console.log('queue ' + name + ' <<<<<<  turned on pending mode');\n    };\n    /**\n     * Check name in queue\n     */\n    StompService.prototype.nameCheck = function (name) {\n        if (!this.config.queue.hasOwnProperty(name)) {\n            throw Error(\"'\" + name + \"' has not found in queue\");\n        }\n    };\n    return StompService;\n}());\nStompService = __decorate([\n    core_1.Injectable()\n], StompService);\nexports.StompService = StompService;\n"],"file":"stomp.service.js"}